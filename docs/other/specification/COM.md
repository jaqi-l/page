
# 13.8 代码组织模式     

|对比维度|Monolithic（单体应用）|Multirepo（多仓多模块）|Monorepo（单仓多模块）|
|--|--|--|--|
|代码组织形式|所有功能模块代码在一个仓库，通过文件层级管理|每个模块有独立代码仓库，模块间相对独立|多个模块代码放在一个仓库，以特定目录结构区分|
|优点|代码管理成本低，开发人员易把握整体架构；发布简单，链路轻便|模块可独立开发调试，人员分工明确，便于代码复用，权限设置灵活|分支管理简单，公共依赖清晰，可并行构建，代码复用性好，代码审查和合并请求集中|
|缺点|代码量大时调试、构建效率低，扩展性差，功能问题可能影响整个应用，无法跨项目复用代码|模块划分难度大，易出现版本问题，构建配置难以复用，发布成本高，代码审查分散|代码规模过大时git操作速度受影响，仓库访问权限按目录划分复杂，包修改提交繁琐|
|适用场景|项目初期，团队规模小，业务逻辑简单，需快速落地业务|团队规模大，业务模块复杂，有代码复用需求，对模块独立开发调试要求高|组件或模块数量多，Multirepo维护成本大，需统一管理依赖和构建流程|
|代码可见性|容易看到整个代码库变化，利于团队协作，但非owner改动代码风险高|一个仓库一个项目，代码可见性高，便于维护|每个人可方便阅读他人代码，利于协作和跨团队贡献，但可能增加非owner改动代码风险|
|依赖管理|嵌入项目内部直接引用，不利于维护|通过npm link或发布到npm，不利于团队协作，易出现版本冲突和重复安装问题|依赖管理简单，可将共同依赖提取至root，版本控制容易|
|代码权限|一个仓库难以精准控制权限，强行控制可能导致构建异常|多个仓库，权限管理简单，可针对单个仓库分配权限|一个仓库，精准控制权限成本高|
|开发迭代|无明显优势，代码量大时开发效率下降|仓库体积小，模块划分清晰，但多仓库切换繁琐，依赖管理不便|可看到相关项目全貌，编码方便，代码复用高，依赖调试方便，但代码体积大时git clone时间长|
|工程配置|多项目在一个仓库，工程配置一致，代码质量标准和风格易统一|各项目构建、打包、代码校验各自维护，可能导致代码或构建差异|多项目在一个仓库，工程配置一致，代码质量标准和风格易统一，但全量构建成本高|
